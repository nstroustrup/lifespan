#ifndef NS_WORM_INTERPOLATION
#define NS_WORM_INTERPOLATION
//#include "ns_movement_characterization.h"
//#include "ns_detected_object.h"
#include "ns_image_server.h"
#include "ns_sql.h"

/*class ns_worm_interpolation_timepoint;

struct ns_reverse_worm_lookup{
	ns_reverse_worm_lookup():interpolated(false){}
	ns_reverse_worm_lookup(const ns_vector_2d & p,const ns_detected_worm_info & w, ns_worm_interpolation_timepoint * l, const bool i):pos(p),worm(&w),info(l),interpolated(i){}
	ns_vector_2d pos;
	//true if the worm is an interpolated worm (rather than a SVM-detected worm)
	bool interpolated;

	const ns_detected_worm_info * worm;
	ns_worm_interpolation_timepoint * info;
};*/



class ns_worm_interpolation_timepoint{
	public:
	ns_worm_interpolation_timepoint():threshold_loaded(false){}
	unsigned long time;
	ns_image_server_captured_image_region region;
	//ns_image_worm_detection_results detected_worms;
	//ns_image_worm_detection_results interpolated_worms;
	ns_image_server_image threshold_image;

	ns_image_standard threshold;
	//bool interpolated_worms_identified;
	bool threshold_loaded;

	void load_threshold(ns_sql & sql);
	void clear_threshold();

	//bool load_region_images(ns_sql & sql);
//	void clear_images();

//	bool loaded_images;

	//ns_detected_object_manager object_manager;

	//void commit_interpolated_regions_to_db(const ns_image_standard * static_mask, std::vector<ns_reverse_worm_lookup> & corresponding_reverse_lookup_table_entry, ns_sql & sql);
};

/*
class ns_worm_interpolation_decision_maker{
public:
	void  identify_interpolated_worm(const ns_detected_worm_info & worm, std::vector<ns_detected_object *> & neighbors,std::vector<ns_detected_object *> & matching_objects);
	ns_detected_object * create_merged_object(const ns_detected_worm_info & worm, std::vector<ns_detected_object *> & neighbors, const std::vector<ns_detected_object *> & matching_objectd);
};*/

class ns_worm_multi_frame_interpolation{
	std::vector<ns_worm_interpolation_timepoint> time_points_storage;
	std::vector<ns_worm_interpolation_timepoint * > time_points;
public:
	void load_all_region_worms(const unsigned int region_info_id, ns_sql & sql, bool only_use_processed_frames=true);
	//void clear_previous_interpolation_results(const unsigned int region_info_id, ns_sql & sql);
	void generate_heat_map(ns_image_standard & heat_map,const unsigned int number_of_frames_used_to_find_stationary_objects,ns_sql & sql);
	static void generate_static_mask_from_heatmap(const ns_image_standard & heat_map, ns_image_standard & out);
//	void interpolate_worms(const ns_image_standard * static_mask,ns_sql & sql);
//	void run_analysis(const ns_image_standard * static_mask,ns_sql & sql);
//
//	void output_worm_images_to_disk(const std::string & path,const std::string & prefix, ns_sql & sql, const unsigned int number_of_time_points_to_use=0);

};

//A heat map is generated by summing all thresholded frames of a time series.  For the first
//third of the time series, treshold values are added to the red channel of the heat map.
//for the second third of the time series, threshold values are added to the green channel
//for the final, blue.
//This means we can roughly inspect which pixels are constantly bright for the biggining, middle, or end
//of the experiment.
//This function looks for pixels that were bright for a specified fraction of each third of the experiment.
//Such bright pixels, if situated in a region where at least one pixel was bright in the two other thirds
//of the experiment, are added to the output image.
//The output image can then be used to mask out unwanted "static" pixels that represent
//features such as the plate edge or dust.


#endif
