#ifndef NS_WORM_DETECTOR
#define NS_WORM_DETECTOR
#include "ns_identify_contiguous_bitmap_regions.h"
#include "ns_detected_object.h"



class ns_object_to_segment_cluster_converter{
public:
///Generates a Delauny triangular mesh for each region present in regions
	void use_delauny_method(std::vector<ns_detected_object *> objects, const bool multiple_worm_disambiguation=true,const std::string & debug_spine_output_filename = "");
	void use_zhang_thinning(std::vector<ns_detected_object *> objects, const bool multiple_worm_disambiguation=true);
};


template<class whole_image>
class ns_worm_detector{
public:
	ns_image_worm_detection_results * run(const whole_image & thresholded_image, const whole_image & grayscale_image, const ns_image_standard * static_mask, const unsigned int & minimum_region_area, const unsigned int &maximum_region_area, const unsigned int &maximum_region_diagonal, const ns_model_specification & model, const std::string & spine_debug_filename_output="", const ns_detected_worm_info::ns_visualization_type visualization_type=ns_detected_worm_info::ns_vis_raster,ns_image_region_stats image_region_stats = ns_image_region_stats::null(),const bool do_multiple_worm_disambiguation=true){
		ns_detected_object_manager object_manager;
		std::cerr << "Identifying objects: ";
		ns_identify_contiguous_bitmap_regions(thresholded_image,object_manager.objects);
		unsigned long init_object_count((unsigned long)object_manager.objects.size());
		object_manager.constrain_region_area(minimum_region_area,maximum_region_area,maximum_region_diagonal);
		std::cerr << object_manager.objects.size() << "/" << init_object_count << " objects accepted.\n";
		if (object_manager.objects.size() > ns_worm_detection_constants::get(ns_worm_detection_constant::maximum_number_of_objects_per_image))
			throw ns_ex("ns_worm_detector::run()::") << (unsigned int)object_manager.objects.size() << " objects identified, more than the specificed " << ns_worm_detection_constants::get(ns_worm_detection_constant::maximum_number_of_objects_per_image) << " cutoff.  Contamination/condensation suspected.";

		ns_image_worm_detection_results * tmp(run(object_manager,grayscale_image,static_mask,model,spine_debug_filename_output,visualization_type,image_region_stats));
		tmp->generate_region_collage(grayscale_image,thresholded_image);
		return tmp;
	}

	///detect all worms in the image, and return information about each worm and non-worm image.
	template<class whole_im>
	ns_image_worm_detection_results * run(ns_detected_object_manager & detected_objects, const whole_im & grayscale_image, const ns_image_standard * static_mask, const ns_model_specification & model, const std::string & debug_filename_output="", const ns_detected_worm_info::ns_visualization_type visualization_type=ns_detected_worm_info::ns_vis_raster, ns_image_region_stats image_region_stats = ns_image_region_stats::null(),const bool do_multiple_worm_disambiguation=true){
		unsigned long start_time = ns_current_time();
		hande_static_mask(detected_objects,grayscale_image, static_mask);

		detected_objects.convert_bitmaps_into_node_graphs(grayscale_image.properties().resolution, debug_filename_output);
		detected_objects.calculate_segment_topologies_from_node_graphs(do_multiple_worm_disambiguation);
		ns_image_worm_detection_results * results = 0;
		results = new ns_image_worm_detection_results();

		try{
	//		cerr << "Generating region results\n";
			//cerr << regions.size() << " regions.\n";
			results->process_segment_cluster_solutions(detected_objects.objects,grayscale_image,visualization_type,ns_worm_detection_constants::get(ns_worm_detection_constant::maximum_number_of_putative_worms_per_image));
			results->calculate_image_region_stats(image_region_stats);
			results->sort_putative_worms(model);

			for (unsigned int i = 0; i < detected_objects.interpolated_objects.size(); i++)
				results->add_interpolated_worm_area(detected_objects.interpolated_objects[i]);

			if (results->number_of_actual_worms() >  ns_worm_detection_constants::get(ns_worm_detection_constant::maximum_number_of_actual_worms_per_image))
				throw ns_ex("ns_worm_detector::run()::") << results->number_of_actual_worms() << " worms detected in image, more than the specified " << ns_worm_detection_constants::get(ns_worm_detection_constant::maximum_number_of_actual_worms_per_image) << " maximum.";

		//	cerr << "Total Detection time: " << ns_current_time() - start_time << "\n";
	//		cerr << "Done.\n";
			return results;
		}
		catch(...){
			delete results;
			throw;
		}
	}

private:



	void hande_static_mask(ns_detected_object_manager & detected_objects, const ns_image_standard & grayscale_image, const ns_image_standard * static_mask){
		if (static_mask != 0){
			if (!(static_mask->properties() == grayscale_image.properties()))
				throw ns_ex("ns_detected_object_identifier::Static mask size does not match grayscale image size ( ")
					<< static_mask->properties().width << "x" << static_mask->properties().height << " vs "
					<< grayscale_image.properties().width << "x" << grayscale_image.properties().height << ")";
			detected_objects.remove_objects_found_in_static_mask(*static_mask);
		}
	}

};


#endif
